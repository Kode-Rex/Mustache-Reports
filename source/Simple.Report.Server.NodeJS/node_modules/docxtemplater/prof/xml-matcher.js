"use strict";
var profile=(profile?profile:(function(){return require("/home/edgar/.local/lib/node_modules/profi-stanbul/profile.js");})());
// res class responsibility is to parse the XML.
var DocUtils=require('./doc-utils');var memoize=require('./memoize');function handleRecursiveCase(res){var _p=profile.start('handleRecursiveCase',__filename,arguments);try{/*
 	 Because xmlTemplater is recursive (meaning it can call it self), we need to handle special cases where the XML is not valid:
 	 For example with res string "I am</w:t></w:r></w:p><w:p><w:r><w:t>sleeping",
 	 - we need to match also the string that is inside an implicit <w:t> (that's the role of replacerUnshift) (in res case 'I am')
 	 - we need to match the string that is at the right of a <w:t> (that's the role of replacerPush) (in res case 'sleeping')
 	 the test: describe "scope calculation" it "should compute the scope between 2 <w:t>" makes sure that res part of code works
 	 It should even work if they is no XML at all, for example if the code is just "I am sleeping", in res case however, they should only be one match
 	 */
function replacerUnshift(){var _p=profile.start('replacerUnshift',__filename,arguments);try{var pn={array:Array.prototype.slice.call(arguments)};pn.array.shift();var match=pn.array[0]+pn.array[1];// add match so that pn[0] = whole match, pn[1]= first parenthesis,...
pn.array.unshift(match);pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.first=true;// add at the beginning
res.matches.unshift(pn);res.charactersAdded.unshift(0);return res.charactersAddedCumulative.unshift(0);}finally{profile.end(_p);}}if(res.content.indexOf('<')===-1&&res.content.indexOf('>')===-1){res.content.replace(/^()([^<>]*)$/,replacerUnshift);}var r=new RegExp('^()([^<]+)</(?:'+res.tagsXmlArrayJoined+')>');res.content.replace(r,replacerUnshift);function replacerPush(){var _p=profile.start('replacerPush',__filename,arguments);try{var pn={array:Array.prototype.slice.call(arguments)};pn.array.pop();var offset=pn.array.pop();pn.offset=offset;pn.last=true;// add at the end
res.matches.push(pn);res.charactersAdded.push(0);return res.charactersAddedCumulative.push(0);}finally{profile.end(_p);}}r=new RegExp('(<(?:'+res.tagsXmlArrayJoined+')[^>]*>)([^>]+)$');res.content.replace(r,replacerPush);return res;}finally{profile.end(_p);}}function xmlMatcher(content,tagsXmlArray){var _p=profile.start('xmlMatcher',__filename,arguments);try{var res={};res.content=content;res.tagsXmlArray=tagsXmlArray;res.tagsXmlArrayJoined=res.tagsXmlArray.join('|');var regexp=new RegExp('(<(?:'+res.tagsXmlArrayJoined+')[^>]*>)([^<>]*)</(?:'+res.tagsXmlArrayJoined+')>','g');res.matches=DocUtils.pregMatchAll(regexp,res.content);res.charactersAddedCumulative=res.matches.map(function(){return 0;});res.charactersAdded=res.matches.map(function(){return 0;});return handleRecursiveCase(res);}finally{profile.end(_p);}}var memoized=memoize(xmlMatcher);module.exports=function(content,tagsXmlArray){var _p=profile.start('module.exports',__filename,arguments);try{return DocUtils.cloneDeep(memoized(content,tagsXmlArray));}finally{profile.end(_p);}};
